/**
 * @license
 * Copyright 2025 Foundry (foundry.app)
 * SPDX-License-Identifier: Apache-2.0
 */

import type Database from 'better-sqlite3';

/**
 * Migration script definition
 */
export interface IMigration {
  version: number; // Target version after this migration
  name: string; // Migration name for logging
  up: (db: Database.Database) => void; // Upgrade script
  down: (db: Database.Database) => void; // Downgrade script (for rollback)
}

/**
 * Migration v0 -> v1: Initial schema
 * This is handled by initSchema() in schema.ts
 */
const migration_v1: IMigration = {
  version: 1,
  name: 'Initial schema',
  up: (_db) => {
    // Already handled by initSchema()
    console.log('[Migration v1] Initial schema created by initSchema()');
  },
  down: (db) => {
    // Drop all tables (only core tables now)
    db.exec(`
      DROP TABLE IF EXISTS messages;
      DROP TABLE IF EXISTS conversations;
      DROP TABLE IF EXISTS users;
    `);
    console.log('[Migration v1] Rolled back: All tables dropped');
  },
};

/**
 * Migration v1 -> v2: Add indexes for better performance
 * Example of a schema change migration
 */
const migration_v2: IMigration = {
  version: 2,
  name: 'Add performance indexes',
  up: (db) => {
    db.exec(`
      -- Add composite index for conversation messages lookup
      CREATE INDEX IF NOT EXISTS idx_messages_conv_created_desc
        ON messages(conversation_id, created_at DESC);

      -- Add index for message search by type
      CREATE INDEX IF NOT EXISTS idx_messages_type_created
        ON messages(type, created_at DESC);

      -- Add index for user conversations lookup
      CREATE INDEX IF NOT EXISTS idx_conversations_user_type
        ON conversations(user_id, type);
    `);
    console.log('[Migration v2] Added performance indexes');
  },
  down: (db) => {
    db.exec(`
      DROP INDEX IF EXISTS idx_messages_conv_created_desc;
      DROP INDEX IF EXISTS idx_messages_type_created;
      DROP INDEX IF EXISTS idx_conversations_user_type;
    `);
    console.log('[Migration v2] Rolled back: Removed performance indexes');
  },
};

/**
 * Migration v2 -> v3: Add full-text search support [REMOVED]
 *
 * Note: FTS functionality has been removed as it's not currently needed.
 * Will be re-implemented when search functionality is added to the UI.
 */
const migration_v3: IMigration = {
  version: 3,
  name: 'Add full-text search (skipped)',
  up: (_db) => {
    // FTS removed - will be re-added when search functionality is implemented
    console.log('[Migration v3] FTS support skipped (removed, will be added back later)');
  },
  down: (db) => {
    // Clean up FTS table if it exists from older versions
    db.exec(`
      DROP TABLE IF EXISTS messages_fts;
    `);
    console.log('[Migration v3] Rolled back: Removed full-text search');
  },
};

/**
 * Migration v3 -> v4: Removed (user_preferences table no longer needed)
 */
const migration_v4: IMigration = {
  version: 4,
  name: 'Removed user_preferences table',
  up: (_db) => {
    // user_preferences table removed from schema
    console.log('[Migration v4] Skipped (user_preferences table removed)');
  },
  down: (_db) => {
    console.log('[Migration v4] Rolled back: No-op (user_preferences table removed)');
  },
};

/**
 * Migration v4 -> v5: Remove FTS table
 * Cleanup for FTS removal - ensures all databases have consistent schema
 */
const migration_v5: IMigration = {
  version: 5,
  name: 'Remove FTS table',
  up: (db) => {
    // Remove FTS table created by old v3 migration
    db.exec(`
      DROP TABLE IF EXISTS messages_fts;
    `);
    console.log('[Migration v5] Removed FTS table (cleanup for FTS removal)');
  },
  down: (_db) => {
    // If rolling back, we don't recreate FTS table (it's deprecated)
    console.log('[Migration v5] Rolled back: FTS table remains removed (deprecated feature)');
  },
};

/**
 * Migration v5 -> v6: Add jwt_secret column to users table
 * Store JWT secret per user for better security and management
 */
const migration_v6: IMigration = {
  version: 6,
  name: 'Add jwt_secret to users table',
  up: (db) => {
    // Check if jwt_secret column already exists
    const tableInfo = db.prepare('PRAGMA table_info(users)').all() as Array<{ name: string }>;
    const hasJwtSecret = tableInfo.some((col) => col.name === 'jwt_secret');

    if (!hasJwtSecret) {
      // Add jwt_secret column to users table
      db.exec(`ALTER TABLE users ADD COLUMN jwt_secret TEXT;`);
      console.log('[Migration v6] Added jwt_secret column to users table');
    } else {
      console.log('[Migration v6] jwt_secret column already exists, skipping');
    }
  },
  down: (db) => {
    // SQLite doesn't support DROP COLUMN directly, need to recreate table
    db.exec(`
      CREATE TABLE users_backup AS SELECT id, username, email, password_hash, avatar_path, created_at, updated_at, last_login FROM users;
      DROP TABLE users;
      ALTER TABLE users_backup RENAME TO users;
      CREATE INDEX IF NOT EXISTS idx_users_username ON users(username);
      CREATE INDEX IF NOT EXISTS idx_users_email ON users(email);
    `);
    console.log('[Migration v6] Rolled back: Removed jwt_secret column from users table');
  },
};

/**
 * Migration v6 -> v7: Add Personal Assistant tables
 * Supports remote interaction through messaging platforms (Telegram, Slack, Discord)
 */
const migration_v7: IMigration = {
  version: 7,
  name: 'Add Personal Assistant tables',
  up: (db) => {
    // Assistant plugins configuration
    db.exec(`
      CREATE TABLE IF NOT EXISTS assistant_plugins (
        id TEXT PRIMARY KEY,
        type TEXT NOT NULL CHECK(type IN ('telegram', 'slack', 'discord')),
        name TEXT NOT NULL,
        enabled INTEGER NOT NULL DEFAULT 0,
        config TEXT NOT NULL,
        status TEXT CHECK(status IN ('created', 'initializing', 'ready', 'starting', 'running', 'stopping', 'stopped', 'error')),
        last_connected INTEGER,
        created_at INTEGER NOT NULL,
        updated_at INTEGER NOT NULL
      );

      CREATE INDEX IF NOT EXISTS idx_assistant_plugins_type ON assistant_plugins(type);
      CREATE INDEX IF NOT EXISTS idx_assistant_plugins_enabled ON assistant_plugins(enabled);
    `);

    // Authorized users whitelist
    db.exec(`
      CREATE TABLE IF NOT EXISTS assistant_users (
        id TEXT PRIMARY KEY,
        platform_user_id TEXT NOT NULL,
        platform_type TEXT NOT NULL,
        display_name TEXT,
        authorized_at INTEGER NOT NULL,
        last_active INTEGER,
        session_id TEXT,
        UNIQUE(platform_user_id, platform_type)
      );

      CREATE INDEX IF NOT EXISTS idx_assistant_users_platform ON assistant_users(platform_type, platform_user_id);
    `);

    // User sessions
    db.exec(`
      CREATE TABLE IF NOT EXISTS assistant_sessions (
        id TEXT PRIMARY KEY,
        user_id TEXT NOT NULL,
        agent_type TEXT NOT NULL CHECK(agent_type IN ('gemini', 'acp', 'codex')),
        conversation_id TEXT,
        workspace TEXT,
        created_at INTEGER NOT NULL,
        last_activity INTEGER NOT NULL,
        FOREIGN KEY (user_id) REFERENCES assistant_users(id) ON DELETE CASCADE,
        FOREIGN KEY (conversation_id) REFERENCES conversations(id) ON DELETE SET NULL
      );

      CREATE INDEX IF NOT EXISTS idx_assistant_sessions_user ON assistant_sessions(user_id);
      CREATE INDEX IF NOT EXISTS idx_assistant_sessions_conversation ON assistant_sessions(conversation_id);
    `);

    // Pending pairing requests
    db.exec(`
      CREATE TABLE IF NOT EXISTS assistant_pairing_codes (
        code TEXT PRIMARY KEY,
        platform_user_id TEXT NOT NULL,
        platform_type TEXT NOT NULL,
        display_name TEXT,
        requested_at INTEGER NOT NULL,
        expires_at INTEGER NOT NULL,
        status TEXT NOT NULL DEFAULT 'pending' CHECK(status IN ('pending', 'approved', 'rejected', 'expired'))
      );

      CREATE INDEX IF NOT EXISTS idx_assistant_pairing_expires ON assistant_pairing_codes(expires_at);
      CREATE INDEX IF NOT EXISTS idx_assistant_pairing_status ON assistant_pairing_codes(status);
    `);

    console.log('[Migration v7] Added Personal Assistant tables');
  },
  down: (db) => {
    db.exec(`
      DROP TABLE IF EXISTS assistant_pairing_codes;
      DROP TABLE IF EXISTS assistant_sessions;
      DROP TABLE IF EXISTS assistant_users;
      DROP TABLE IF EXISTS assistant_plugins;
    `);
    console.log('[Migration v7] Rolled back: Removed Personal Assistant tables');
  },
};

/**
 * Migration v7 -> v8: Add source column to conversations table
 * Identifies conversation source
 */
const migration_v8: IMigration = {
  version: 8,
  name: 'Add source column to conversations',
  up: (db) => {
    // Add source column to conversations table
    db.exec(`
      ALTER TABLE conversations ADD COLUMN source TEXT CHECK(source IN ('foundry', 'telegram'));
    `);

    // Create index for efficient source-based queries
    db.exec(`
      CREATE INDEX IF NOT EXISTS idx_conversations_source ON conversations(source);
      CREATE INDEX IF NOT EXISTS idx_conversations_source_updated ON conversations(source, updated_at DESC);
    `);

    console.log('[Migration v8] Added source column to conversations table');
  },
  down: (db) => {
    // SQLite doesn't support DROP COLUMN directly, need to recreate table
    // For simplicity, just drop the indexes (column will remain)
    db.exec(`
      DROP INDEX IF EXISTS idx_conversations_source;
      DROP INDEX IF EXISTS idx_conversations_source_updated;
    `);
    console.log('[Migration v8] Rolled back: Removed source indexes');
  },
};

/**
 * Migration v8 -> v9: Add cron_jobs table for scheduled tasks
 */
const migration_v9: IMigration = {
  version: 9,
  name: 'Add cron_jobs table',
  up: (db) => {
    db.exec(`
      CREATE TABLE IF NOT EXISTS cron_jobs (
        -- Basic info
        id TEXT PRIMARY KEY,
        name TEXT NOT NULL,
        enabled INTEGER DEFAULT 1,

        -- Schedule
        schedule_kind TEXT NOT NULL,       -- 'at' | 'every' | 'cron'
        schedule_value TEXT NOT NULL,      -- timestamp | ms | cron expr
        schedule_tz TEXT,                  -- timezone (optional)
        schedule_description TEXT NOT NULL, -- human-readable description

        -- Target
        payload_message TEXT NOT NULL,

        -- Metadata (for management)
        conversation_id TEXT NOT NULL,     -- Which conversation created this
        conversation_title TEXT,           -- For display in UI
        agent_type TEXT NOT NULL,          -- 'gemini' | 'claude' | 'codex' | etc.
        created_by TEXT NOT NULL,          -- 'user' | 'agent'
        created_at INTEGER DEFAULT (strftime('%s', 'now') * 1000),
        updated_at INTEGER DEFAULT (strftime('%s', 'now') * 1000),

        -- Runtime state
        next_run_at INTEGER,
        last_run_at INTEGER,
        last_status TEXT,                  -- 'ok' | 'error' | 'skipped'
        last_error TEXT,                   -- Error message if failed
        run_count INTEGER DEFAULT 0,
        retry_count INTEGER DEFAULT 0,
        max_retries INTEGER DEFAULT 3
      );

      -- Index for querying jobs by conversation (frontend management)
      CREATE INDEX IF NOT EXISTS idx_cron_jobs_conversation ON cron_jobs(conversation_id);

      -- Index for scheduler to find next jobs to run
      CREATE INDEX IF NOT EXISTS idx_cron_jobs_next_run ON cron_jobs(next_run_at) WHERE enabled = 1;

      -- Index for querying by agent type (if needed)
      CREATE INDEX IF NOT EXISTS idx_cron_jobs_agent_type ON cron_jobs(agent_type);
    `);
    console.log('[Migration v9] Added cron_jobs table');
  },
  down: (db) => {
    db.exec(`
      DROP INDEX IF EXISTS idx_cron_jobs_agent_type;
      DROP INDEX IF EXISTS idx_cron_jobs_next_run;
      DROP INDEX IF EXISTS idx_cron_jobs_conversation;
      DROP TABLE IF EXISTS cron_jobs;
    `);
    console.log('[Migration v9] Rolled back: Removed cron_jobs table');
  },
};

/**
 * Migration v9 -> v10: Add 'lark' to assistant_plugins type constraint
 */
const migration_v10: IMigration = {
  version: 10,
  name: 'Add lark to assistant_plugins type constraint',
  up: (db) => {
    // SQLite doesn't support ALTER TABLE to modify CHECK constraints
    // We need to recreate the table with the new constraint
    db.exec(`
      -- Create new table with updated constraint
      CREATE TABLE IF NOT EXISTS assistant_plugins_new (
        id TEXT PRIMARY KEY,
        type TEXT NOT NULL CHECK(type IN ('telegram', 'slack', 'discord', 'lark')),
        name TEXT NOT NULL,
        enabled INTEGER NOT NULL DEFAULT 0,
        config TEXT NOT NULL,
        status TEXT CHECK(status IN ('created', 'initializing', 'ready', 'starting', 'running', 'stopping', 'stopped', 'error')),
        last_connected INTEGER,
        created_at INTEGER NOT NULL,
        updated_at INTEGER NOT NULL
      );

      -- Copy data from old table (if exists)
      INSERT OR IGNORE INTO assistant_plugins_new SELECT * FROM assistant_plugins;

      -- Drop old table
      DROP TABLE IF EXISTS assistant_plugins;

      -- Rename new table
      ALTER TABLE assistant_plugins_new RENAME TO assistant_plugins;

      -- Recreate indexes
      CREATE INDEX IF NOT EXISTS idx_assistant_plugins_type ON assistant_plugins(type);
      CREATE INDEX IF NOT EXISTS idx_assistant_plugins_enabled ON assistant_plugins(enabled);
    `);

    console.log('[Migration v10] Added lark to assistant_plugins type constraint');
  },
  down: (db) => {
    // Rollback: recreate table without lark type (data with lark type will be lost)
    db.exec(`
      CREATE TABLE IF NOT EXISTS assistant_plugins_old (
        id TEXT PRIMARY KEY,
        type TEXT NOT NULL CHECK(type IN ('telegram', 'slack', 'discord')),
        name TEXT NOT NULL,
        enabled INTEGER NOT NULL DEFAULT 0,
        config TEXT NOT NULL,
        status TEXT CHECK(status IN ('created', 'initializing', 'ready', 'starting', 'running', 'stopping', 'stopped', 'error')),
        last_connected INTEGER,
        created_at INTEGER NOT NULL,
        updated_at INTEGER NOT NULL
      );

      INSERT OR IGNORE INTO assistant_plugins_old SELECT * FROM assistant_plugins WHERE type != 'lark';

      DROP TABLE IF EXISTS assistant_plugins;

      ALTER TABLE assistant_plugins_old RENAME TO assistant_plugins;

      CREATE INDEX IF NOT EXISTS idx_assistant_plugins_type ON assistant_plugins(type);
      CREATE INDEX IF NOT EXISTS idx_assistant_plugins_enabled ON assistant_plugins(enabled);
    `);
    console.log('[Migration v10] Rolled back: Removed lark from assistant_plugins type constraint');
  },
};

/**
 * Migration v10 -> v11: Fix source column case sensitivity
 * Update 'Foundry' to 'foundry' and fix the CHECK constraint
 */
const migration_v11: IMigration = {
  version: 11,
  name: 'Fix source column case sensitivity',
  up: (db) => {
    // SQLite doesn't support modifying CHECK constraints directly
    // We need to recreate the table with the correct constraint
    db.exec(`
      -- Update any existing 'Foundry' values to 'foundry'
      UPDATE conversations SET source = 'foundry' WHERE source = 'Foundry';

      -- Create new table with correct constraint (lowercase 'foundry')
      CREATE TABLE IF NOT EXISTS conversations_new (
        id TEXT PRIMARY KEY,
        user_id TEXT NOT NULL,
        name TEXT NOT NULL,
        type TEXT NOT NULL CHECK(type IN ('gemini', 'acp', 'codex')),
        extra TEXT NOT NULL,
        model TEXT,
        status TEXT CHECK(status IN ('pending', 'running', 'finished')),
        created_at INTEGER NOT NULL,
        updated_at INTEGER NOT NULL,
        source TEXT CHECK(source IN ('foundry', 'telegram')),
        FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
      );

      -- Copy data from old table
      INSERT INTO conversations_new SELECT id, user_id, name, type, extra, model, status, created_at, updated_at, source FROM conversations;

      -- Drop old table
      DROP TABLE conversations;

      -- Rename new table
      ALTER TABLE conversations_new RENAME TO conversations;

      -- Recreate all indexes
      CREATE INDEX IF NOT EXISTS idx_conversations_user_id ON conversations(user_id);
      CREATE INDEX IF NOT EXISTS idx_conversations_updated_at ON conversations(updated_at);
      CREATE INDEX IF NOT EXISTS idx_conversations_type ON conversations(type);
      CREATE INDEX IF NOT EXISTS idx_conversations_user_updated ON conversations(user_id, updated_at DESC);
      CREATE INDEX IF NOT EXISTS idx_conversations_source ON conversations(source);
      CREATE INDEX IF NOT EXISTS idx_conversations_source_updated ON conversations(source, updated_at DESC);
    `);

    console.log('[Migration v11] Fixed source column case sensitivity (Foundry -> foundry)');
  },
  down: (db) => {
    // No real rollback needed - lowercase is correct
    console.log('[Migration v11] Rolled back: No action needed');
  },
};

/**
 * Migration v11 -> v12: Add 'image' to conversations type constraint
 * Allows standalone image generation conversations
 */
const migration_v12: IMigration = {
  version: 12,
  name: 'Add image to conversations type constraint',
  up: (db) => {
    db.exec(`
      CREATE TABLE IF NOT EXISTS conversations_new (
        id TEXT PRIMARY KEY,
        user_id TEXT NOT NULL,
        name TEXT NOT NULL,
        type TEXT NOT NULL CHECK(type IN ('gemini', 'acp', 'codex', 'image')),
        extra TEXT NOT NULL,
        model TEXT,
        status TEXT CHECK(status IN ('pending', 'running', 'finished')),
        created_at INTEGER NOT NULL,
        updated_at INTEGER NOT NULL,
        source TEXT CHECK(source IN ('foundry', 'telegram')),
        FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
      );

      INSERT INTO conversations_new SELECT id, user_id, name, type, extra, model, status, created_at, updated_at, source FROM conversations;

      DROP TABLE conversations;

      ALTER TABLE conversations_new RENAME TO conversations;

      CREATE INDEX IF NOT EXISTS idx_conversations_user_id ON conversations(user_id);
      CREATE INDEX IF NOT EXISTS idx_conversations_updated_at ON conversations(updated_at);
      CREATE INDEX IF NOT EXISTS idx_conversations_type ON conversations(type);
      CREATE INDEX IF NOT EXISTS idx_conversations_user_updated ON conversations(user_id, updated_at DESC);
      CREATE INDEX IF NOT EXISTS idx_conversations_source ON conversations(source);
      CREATE INDEX IF NOT EXISTS idx_conversations_source_updated ON conversations(source, updated_at DESC);
    `);

    console.log('[Migration v12] Added image to conversations type constraint');
  },
  down: (db) => {
    db.exec(`
      CREATE TABLE IF NOT EXISTS conversations_old (
        id TEXT PRIMARY KEY,
        user_id TEXT NOT NULL,
        name TEXT NOT NULL,
        type TEXT NOT NULL CHECK(type IN ('gemini', 'acp', 'codex')),
        extra TEXT NOT NULL,
        model TEXT,
        status TEXT CHECK(status IN ('pending', 'running', 'finished')),
        created_at INTEGER NOT NULL,
        updated_at INTEGER NOT NULL,
        source TEXT CHECK(source IN ('foundry', 'telegram')),
        FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
      );

      INSERT OR IGNORE INTO conversations_old SELECT * FROM conversations WHERE type != 'image';

      DROP TABLE IF EXISTS conversations;

      ALTER TABLE conversations_old RENAME TO conversations;

      CREATE INDEX IF NOT EXISTS idx_conversations_user_id ON conversations(user_id);
      CREATE INDEX IF NOT EXISTS idx_conversations_updated_at ON conversations(updated_at);
      CREATE INDEX IF NOT EXISTS idx_conversations_type ON conversations(type);
      CREATE INDEX IF NOT EXISTS idx_conversations_user_updated ON conversations(user_id, updated_at DESC);
      CREATE INDEX IF NOT EXISTS idx_conversations_source ON conversations(source);
      CREATE INDEX IF NOT EXISTS idx_conversations_source_updated ON conversations(source, updated_at DESC);
    `);
    console.log('[Migration v12] Rolled back: Removed image from conversations type constraint');
  },
};

/**
 * Migration v12 -> v13: Remove all CHECK constraints (Decision D-004)
 * Validation moves to Zod at TypeScript layer. This is the LAST table-recreation migration.
 * Future type/source additions no longer need migrations.
 */
const migration_v13: IMigration = {
  version: 13,
  name: 'Remove CHECK constraints — Zod validation at TypeScript layer',
  up: (db) => {
    // Recreate conversations table WITHOUT any CHECK constraints
    db.prepare(`DROP TABLE IF EXISTS conversations_new`).run();

    db.prepare(
      `
      CREATE TABLE conversations_new (
        id TEXT PRIMARY KEY,
        user_id TEXT NOT NULL,
        name TEXT NOT NULL,
        type TEXT NOT NULL,
        extra TEXT NOT NULL,
        model TEXT,
        status TEXT,
        created_at INTEGER NOT NULL,
        updated_at INTEGER NOT NULL,
        source TEXT,
        FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
      )
    `
    ).run();

    db.prepare(`INSERT INTO conversations_new SELECT id, user_id, name, type, extra, model, status, created_at, updated_at, source FROM conversations`).run();
    db.prepare(`DROP TABLE conversations`).run();
    db.prepare(`ALTER TABLE conversations_new RENAME TO conversations`).run();

    // Recreate indexes
    db.prepare(`CREATE INDEX IF NOT EXISTS idx_conversations_user_id ON conversations(user_id)`).run();
    db.prepare(`CREATE INDEX IF NOT EXISTS idx_conversations_updated_at ON conversations(updated_at)`).run();
    db.prepare(`CREATE INDEX IF NOT EXISTS idx_conversations_type ON conversations(type)`).run();
    db.prepare(`CREATE INDEX IF NOT EXISTS idx_conversations_user_updated ON conversations(user_id, updated_at DESC)`).run();
    db.prepare(`CREATE INDEX IF NOT EXISTS idx_conversations_source ON conversations(source)`).run();
    db.prepare(`CREATE INDEX IF NOT EXISTS idx_conversations_source_updated ON conversations(source, updated_at DESC)`).run();

    // Recreate messages table WITHOUT CHECK constraints
    db.prepare(`DROP TABLE IF EXISTS messages_new`).run();

    db.prepare(
      `
      CREATE TABLE messages_new (
        id TEXT PRIMARY KEY,
        conversation_id TEXT NOT NULL,
        msg_id TEXT,
        type TEXT NOT NULL,
        content TEXT NOT NULL,
        position TEXT,
        status TEXT,
        created_at INTEGER NOT NULL,
        FOREIGN KEY (conversation_id) REFERENCES conversations(id) ON DELETE CASCADE
      )
    `
    ).run();

    db.prepare(`INSERT INTO messages_new SELECT * FROM messages`).run();
    db.prepare(`DROP TABLE messages`).run();
    db.prepare(`ALTER TABLE messages_new RENAME TO messages`).run();

    // Recreate message indexes
    db.prepare(`CREATE INDEX IF NOT EXISTS idx_messages_conversation_id ON messages(conversation_id)`).run();
    db.prepare(`CREATE INDEX IF NOT EXISTS idx_messages_created_at ON messages(created_at)`).run();
    db.prepare(`CREATE INDEX IF NOT EXISTS idx_messages_type ON messages(type)`).run();
    db.prepare(`CREATE INDEX IF NOT EXISTS idx_messages_msg_id ON messages(msg_id)`).run();
    db.prepare(`CREATE INDEX IF NOT EXISTS idx_messages_conversation_created ON messages(conversation_id, created_at)`).run();

    console.log('[Migration v13] Removed all CHECK constraints — validation now at TypeScript/Zod layer');
  },
  down: (db) => {
    console.log('[Migration v13] Rolled back: No action (CHECK constraints not restored to keep forward compat)');
  },
};

/**
 * Migration v13 -> v14: Add Persistent Memory tables (Phase 5)
 * memory_chunks — stores memories with FTS5 full-text search
 * user_profile — key-value store for learned user preferences
 */
const migration_v14: IMigration = {
  version: 14,
  name: 'Add Persistent Memory tables',
  up: (db) => {
    // Memory chunks — core memory storage
    db.prepare(
      `
      CREATE TABLE IF NOT EXISTS memory_chunks (
        id TEXT PRIMARY KEY,
        workspace TEXT,
        conversation_id TEXT,
        type TEXT NOT NULL,
        source TEXT NOT NULL DEFAULT 'auto',
        content TEXT NOT NULL,
        tags TEXT,
        importance INTEGER NOT NULL DEFAULT 5,
        access_count INTEGER NOT NULL DEFAULT 0,
        last_accessed INTEGER,
        created_at INTEGER NOT NULL,
        updated_at INTEGER NOT NULL
      )
    `
    ).run();

    db.prepare(`CREATE INDEX IF NOT EXISTS idx_memory_workspace ON memory_chunks(workspace)`).run();
    db.prepare(`CREATE INDEX IF NOT EXISTS idx_memory_type ON memory_chunks(type)`).run();
    db.prepare(`CREATE INDEX IF NOT EXISTS idx_memory_importance ON memory_chunks(importance DESC)`).run();
    db.prepare(`CREATE INDEX IF NOT EXISTS idx_memory_created ON memory_chunks(created_at DESC)`).run();
    db.prepare(`CREATE INDEX IF NOT EXISTS idx_memory_workspace_type ON memory_chunks(workspace, type)`).run();
    db.prepare(`CREATE INDEX IF NOT EXISTS idx_memory_conversation ON memory_chunks(conversation_id)`).run();

    // FTS5 virtual table for full-text search with BM25 ranking
    db.prepare(
      `
      CREATE VIRTUAL TABLE IF NOT EXISTS memory_chunks_fts USING fts5(
        content,
        tags,
        content='memory_chunks',
        content_rowid='rowid',
        tokenize='porter unicode61'
      )
    `
    ).run();

    // Triggers to keep FTS index in sync
    db.prepare(
      `
      CREATE TRIGGER IF NOT EXISTS memory_chunks_ai AFTER INSERT ON memory_chunks BEGIN
        INSERT INTO memory_chunks_fts(rowid, content, tags)
        VALUES (new.rowid, new.content, new.tags);
      END
    `
    ).run();

    db.prepare(
      `
      CREATE TRIGGER IF NOT EXISTS memory_chunks_ad AFTER DELETE ON memory_chunks BEGIN
        INSERT INTO memory_chunks_fts(memory_chunks_fts, rowid, content, tags)
        VALUES ('delete', old.rowid, old.content, old.tags);
      END
    `
    ).run();

    db.prepare(
      `
      CREATE TRIGGER IF NOT EXISTS memory_chunks_au AFTER UPDATE ON memory_chunks BEGIN
        INSERT INTO memory_chunks_fts(memory_chunks_fts, rowid, content, tags)
        VALUES ('delete', old.rowid, old.content, old.tags);
        INSERT INTO memory_chunks_fts(rowid, content, tags)
        VALUES (new.rowid, new.content, new.tags);
      END
    `
    ).run();

    // User profile — learned preferences and patterns
    db.prepare(
      `
      CREATE TABLE IF NOT EXISTS user_profile (
        id TEXT PRIMARY KEY,
        category TEXT NOT NULL,
        key TEXT NOT NULL,
        value TEXT NOT NULL,
        confidence REAL NOT NULL DEFAULT 0.5,
        evidence_count INTEGER NOT NULL DEFAULT 1,
        created_at INTEGER NOT NULL,
        updated_at INTEGER NOT NULL,
        UNIQUE(category, key)
      )
    `
    ).run();

    db.prepare(`CREATE INDEX IF NOT EXISTS idx_profile_category ON user_profile(category)`).run();
    db.prepare(`CREATE INDEX IF NOT EXISTS idx_profile_confidence ON user_profile(confidence DESC)`).run();

    console.log('[Migration v14] Added Persistent Memory tables (memory_chunks + FTS5 + user_profile)');
  },
  down: (db) => {
    db.prepare(`DROP TRIGGER IF EXISTS memory_chunks_au`).run();
    db.prepare(`DROP TRIGGER IF EXISTS memory_chunks_ad`).run();
    db.prepare(`DROP TRIGGER IF EXISTS memory_chunks_ai`).run();
    db.prepare(`DROP TABLE IF EXISTS memory_chunks_fts`).run();
    db.prepare(`DROP TABLE IF EXISTS user_profile`).run();
    db.prepare(`DROP TABLE IF EXISTS memory_chunks`).run();
    console.log('[Migration v14] Rolled back: Removed Persistent Memory tables');
  },
};

/**
 * All migrations in order
 */
export const ALL_MIGRATIONS: IMigration[] = [migration_v1, migration_v2, migration_v3, migration_v4, migration_v5, migration_v6, migration_v7, migration_v8, migration_v9, migration_v10, migration_v11, migration_v12, migration_v13, migration_v14];

/**
 * Get migrations needed to upgrade from one version to another
 */
export function getMigrationsToRun(fromVersion: number, toVersion: number): IMigration[] {
  return ALL_MIGRATIONS.filter((m) => m.version > fromVersion && m.version <= toVersion).sort((a, b) => a.version - b.version);
}

/**
 * Get migrations needed to downgrade from one version to another
 */
export function getMigrationsToRollback(fromVersion: number, toVersion: number): IMigration[] {
  return ALL_MIGRATIONS.filter((m) => m.version > toVersion && m.version <= fromVersion).sort((a, b) => b.version - a.version);
}

/**
 * Run migrations in a transaction
 */
export function runMigrations(db: Database.Database, fromVersion: number, toVersion: number): void {
  if (fromVersion === toVersion) {
    console.log('[Migrations] Already at target version');
    return;
  }

  if (fromVersion > toVersion) {
    throw new Error(`[Migrations] Downgrade not supported in production. Use rollbackMigration() for testing only.`);
  }

  const migrations = getMigrationsToRun(fromVersion, toVersion);

  if (migrations.length === 0) {
    console.log(`[Migrations] No migrations needed from v${fromVersion} to v${toVersion}`);
    return;
  }

  console.log(`[Migrations] Running ${migrations.length} migrations from v${fromVersion} to v${toVersion}`);

  // Run all migrations in a single transaction
  const runAll = db.transaction(() => {
    for (const migration of migrations) {
      try {
        console.log(`[Migrations] Running migration v${migration.version}: ${migration.name}`);
        migration.up(db);

        console.log(`[Migrations] ✓ Migration v${migration.version} completed`);
      } catch (error) {
        console.error(`[Migrations] ✗ Migration v${migration.version} failed:`, error);
        throw error; // Transaction will rollback
      }
    }
  });

  try {
    runAll();
    console.log(`[Migrations] All migrations completed successfully`);
  } catch (error) {
    console.error('[Migrations] Migration failed, all changes rolled back:', error);
    throw error;
  }
}

/**
 * Rollback migrations (for testing/emergency use)
 * WARNING: This can cause data loss!
 */
export function rollbackMigrations(db: Database.Database, fromVersion: number, toVersion: number): void {
  if (fromVersion <= toVersion) {
    throw new Error('[Migrations] Cannot rollback to a higher or equal version');
  }

  const migrations = getMigrationsToRollback(fromVersion, toVersion);

  if (migrations.length === 0) {
    console.log(`[Migrations] No rollback needed from v${fromVersion} to v${toVersion}`);
    return;
  }

  console.log(`[Migrations] Rolling back ${migrations.length} migrations from v${fromVersion} to v${toVersion}`);
  console.warn('[Migrations] WARNING: This may cause data loss!');

  // Run all rollbacks in a single transaction
  const rollbackAll = db.transaction(() => {
    for (const migration of migrations) {
      try {
        console.log(`[Migrations] Rolling back migration v${migration.version}: ${migration.name}`);
        migration.down(db);

        console.log(`[Migrations] ✓ Rollback v${migration.version} completed`);
      } catch (error) {
        console.error(`[Migrations] ✗ Rollback v${migration.version} failed:`, error);
        throw error; // Transaction will rollback
      }
    }
  });

  try {
    rollbackAll();
    console.log(`[Migrations] All rollbacks completed successfully`);
  } catch (error) {
    console.error('[Migrations] Rollback failed:', error);
    throw error;
  }
}

/**
 * Get migration history
 * Now simplified - just returns the current version
 */
export function getMigrationHistory(db: Database.Database): Array<{ version: number; name: string; timestamp: number }> {
  const currentVersion = db.pragma('user_version', { simple: true }) as number;

  // Return a simple array with just the current version
  return [
    {
      version: currentVersion,
      name: `Current schema version`,
      timestamp: Date.now(),
    },
  ];
}

/**
 * Check if a specific migration has been applied
 * Now simplified - checks if current version >= target version
 */
export function isMigrationApplied(db: Database.Database, version: number): boolean {
  const currentVersion = db.pragma('user_version', { simple: true }) as number;
  return currentVersion >= version;
}
